# -*- coding: utf-8 -*-
"""MED_Lw2_ultrasound2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T1kvhqZqJFUJ9_jolPnptm63GKrDkQVk
"""

import os
import pandas as pd
import numpy as np
import cv2
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split

from tensorflow.keras import layers, models

from google.colab import drive

drive.mount('/content/drive')

train_pixel_size_path = '/content/drive/My Drive/B3_code/ultrasound_dataset/training_set_pixel_size_and_HC.csv'
test_pixel_size_path = '/content/drive/My Drive/B3_code/ultrasound_dataset/test_set_pixel_size.csv'

train_df = pd.read_csv(train_pixel_size_path)
test_df = pd.read_csv(test_pixel_size_path)

train_df.head()

images_dir = '/content/drive/My Drive/B3_code/ultrasound_dataset/training_set'
annotations_dir = '/content/drive/My Drive/B3_code/ultrasound_dataset/training_set'

def load_image_and_annotation(image_path, annotation_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    image = cv2.resize(image, (224, 224))
    image = image / 255.0

    annotation = cv2.imread(annotation_path, cv2.IMREAD_GRAYSCALE)
    annotation = cv2.resize(annotation, (224, 224))

    return image, annotation

def prepare_data(df, images_dir, annotations_dir):
    images = []
    labels = []

    for _, row in df.iterrows():
        image_path = os.path.join(images_dir, row['filename'])
        annotation_path = os.path.join(
            annotations_dir,
            row['filename'].replace('.png', '_Annotation.png')
        )

        image, _ = load_image_and_annotation(image_path, annotation_path)
        images.append(image)
        labels.append(row['head circumference (mm)'])

    return np.array(images), np.array(labels)

X_train, y_train = prepare_data(train_df, images_dir, annotations_dir)
X_train = X_train.reshape(-1, 224, 224, 1)

# y_mean = y_train.mean()
# y_std = y_train.std()

# y_train_norm = (y_train - y_mean) / y_std

def build_model():
    model = models.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 1)),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(128, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Flatten(),
        layers.Dense(128, activation='relu'),
        layers.Dense(1)
    ])

    model.compile(optimizer='adam', loss='mse', metrics=['mae'])
    return model

model = build_model()
model.summary()

from sklearn.model_selection import train_test_split
import numpy as np

X_tr, X_val, y_tr, y_val = train_test_split(
    X_train, y_train, test_size=0.2, random_state=42
)

# Normalize
y_mean = y_tr.mean()
y_std = y_tr.std()

y_tr_norm = (y_tr - y_mean) / y_std
y_val_norm = (y_val - y_mean) / y_std


history = model.fit(
    X_tr,
    y_tr_norm,
    epochs=10,
    batch_size=32,
    validation_data=(X_val, y_val_norm)
)

val_loss, val_mae_norm = model.evaluate(X_val, y_val_norm)

# milimeters
val_mae_mm = val_mae_norm * y_std
print(f"Validation MAE: {val_mae_mm:.2f} mm")

plt.figure()
plt.plot(history.history['mae'], label='Training MAE')
plt.plot(history.history['val_mae'], label='Validation MAE')
plt.xlabel('Epoch')
plt.ylabel('Mean Absolute Error (mm)')
plt.legend()
plt.title('Training and Validation MAE')
plt.show()

def prepare_test_data(df, images_dir):
    images = []

    for _, row in df.iterrows():
        image_path = os.path.join(images_dir, row['filename'])
        image, _ = load_image_and_annotation(image_path, image_path)
        images.append(image)

    return np.array(images)

X_test = prepare_test_data(
    test_df,
    '/content/drive/My Drive/B3_code/ultrasound_dataset/test_set'
)
X_test = X_test.reshape(-1, 224, 224, 1)

y_pred = model.predict(X_test)

test_df['predicted_head_circumference'] = y_pred
test_df.to_csv(
    '/content/drive/My Drive/B3_code/ultrasound_dataset/test_predictions.csv',
    index=False
)

test_df[['filename', 'predicted_head_circumference']].head()

